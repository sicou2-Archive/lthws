0 The Setup
Nothing to Review, Python is Running
Maybe look in to gettin Python to Run on Treebow

1 A Good First Program
print()
$ python programName.py

2 Comments and Pound Characters
# to comment or disable lines of code
Debug trick read lines of code backwards (bottom up)


3 Numbers and Math
+, -, /, * (Modulus), %, <, >, <=, >= 
Normal Order of Operations

4 Variables and Names
variable_names with _ (underscore)
variable assigned with = 
can do things after = like math
print("There are ", variable, " here sep by ','.") 
4 = integer
3.0 = floating point number

5 More Variables and Printing
String with ' or " quotes
print(f"strings {variable} without needing loony cat")
variable = adding + or - sub * things_together
variables starting with numbers is no go in Python
round() is an option when working with floating points
6 Strings and Text
Strings are text you want to display or export out of the program
f"strings" can also be done with .format() suntax
	ex: variable.format(thing_to change_in_{}_of_variable)
		Not super strong with this

7 More Printing
print(can + concatinate + strings + of + variables + together + to 
      + print)
print('thing print', end=' ') can change the behavior of print from \n
    at the end of the line to a ' ' or whatever you please, there is 
	also (?) a sep= command I think? Maybe?

8 Printing, Printing
This ex hits .format() pretty well
formatter = '{} {} {} {}'
print(formatter.format(1, 2, 3, 4)


9 Printing, Printing, Printing
\n as escape characters
print('string', and_variable)
'''
Tripple quotes
'''

10 What Was That?
\ to esacpe in string
" \" "
' \' '
List of most (all?) of Python escape characters. 

11 Asking Questions
Software: takes input, changes it, shows what changed
print('thing',end='\n') <- New line by default

12 Prompting People
input('<> Phrase or symbol string you want to precede the cursor')
variable = input('> ')
Getting help out of Python Help in Windows has been hard.
One example that works is "python -m pydoc input" where input is the 
    term we are looking to learn about.
Cannot assign to a variable within print()

13 Parameters, Unpacking, Variables
sys.argv allows the passing of variables from the command line
argv = Argument Variable
from sys import argv -> needs only argv for call to work
    or
import sys -> needs sys.argv for call to work
'python program.py variable_1.txt variable_2'
within program.py -> 'script_name, text_doc, username = argv'
the three variables are now three variables you can work with that came
    from outside the program. 
You import 'modules' (other files), they are called modules, though in 
    reality, they are just other files. In other languages, they are
	also called libraries. They contain variables, code, and functions, 
	that you can use without having to write it yourself. So we can be 
	lazy. You an also think about them as black boxes. You do not really
	need to know what is going on inside as long as they work. 
Be careful of ValueErrors, too many or not enough arguments
For optional arguments look for *args or **kwargs
Command Line Arguments are strings, though they can be changed; int()

14 Prompting and Passing
The input('prompt') can be assigned variable prompt of some kind and 
    change it as needed.


15 Reading Files
open(text_file_name.txt, or_variable_with_file_name)
   this opens the file and returns a 'file object', there are optional
   modes for opening these files, read, write, etc.;
txt.read() which reads some quantity of data and returns it as a string 
	(in text mode) or bytes object (in binary mode); byte mode is 
	selected with the open function. EOF returns an empty string ('')
Not sure what I was doing wrong, but I got the open and read to work in 
the Python Shell
txt.close(); do not forget to close files after done with them to
	prevent strange things from happening. 
open(file_variable) does not return the contents of the file, instead, 
    it returns a "file object"
	
16 Reading and Writing Files
Some methods and functions:
	open(text_file,[other parameters that can be used, look them up
		 if needed]) this opens and returns a file object of the called 
		file, 
	.close() this closes the opened file
	.read() this reads the whole contents of the file, can be assigned
		to a variable
	.readline() this reads a line, it also seems to keep an internal 
		buffer of where it is in the file, it separates lines by the
		*gasp* \n 
	.truncate() this empties the file. *THIS EMPTIES THE FILE*
	.write('things to be written') this writes strings to the current
		file object position, it will return the number of characters 
		written, I am sure that is useful somehow. 
	.seek(0,[0,1,2])  first position is the offset from the whence
		(second argument). Whence == 0 = beginning , == 1 = current
		position, == 2 = EOF, can be omitted and defaults to 0.
		.tell() this might be useful when dealing with seek. It seems to
			return an integer giving the file objects current position
			in the file represented by the number of bytes from the 
			beginning of the file in binary mode, or some other number
			when in text mode (the documentation is not super clear)
			
17 More Files
from os.path import exists
	os.path.exists() (or in this case just exists() since we used
		from to import; 
	This seems to be used to see if the file it checking for exists
		(no kidding huh?), you might be able to use this to prevent
		over-writing other files or the like. 
I am a little murky about this ex and the .close(). Not super sure 
	why and when to use it. 

18 Names, Variables, Code, Functions
Functions do 3 things
	1 Name pieces of code in the way variables name strings and numbers 
	2 They take arguments the way scripts take 'argv'
	3 With 1 and 2 you can make 'mini-scripts' or 'tiny commands'
def creates a function in Python
def name_o_function(args): <- DO NOT FORGET THE COLON : : : : : :
	can do args a few different ways
	(*args)
		arg1, arg2 = args <- This was seems like it lets you get away 
			with not having to always have the same number of args if 
			that changes from time to time. 
	(arg1, arg2)
		this requires two args, can have as many or as few as needed 
		(zero is included)
The arguments defined in a function, DO NOT need to match name wise what
is actually passed to the def, however they must remain internally 
consistant with in the function
Function Checklist
1 Did you start your function definition with def?
2 Does your function name have only characters and _?
3 Did you put an open paren right after the function name?
4 Did you put your args after the paren separated by ,?
5 Did you make each arg unique? 
6 Did you put a close paren after the args?
7 Did you indent all lined of code in the function with FOUR spaces?
8 Did you close the function by dedenting the next line?

Running a Function Checklist
1 Did you call this function by typing its name?
2 Did you put an open paren?
3 Did you add all of the args it would call?
4 Did you close the paren?
	
19 Functions and Variables
Global variables are not immediately available in a function, nor are 
	local variables available outside of a function unless returned from
	it. 
You can put numbers, Boolian, variables, strings, and you can use equations that, 
	calculate down to a single function as argument calls when calling
	a function. 
Remember that input() return the *string* of whatever the imput is. In 
	order to use it as a number you must int('string') 
Typically try to limit the number of arguments that a function calls to 
	less than 5

20 Functions and Files
There is not a whole lot that is new in this ex. Look through it and it
is pretty straight forward. 
It does use .readline() and .seek() incase a worked example is needed. 
Introduces += to increment
readline() is code that scans each byte of the file intil if finds a 
	'\n' character, then stops reading the file to return what it found 
	so far. The file object is responsible for maintaining the current 
	position in the file after each readline() call, so that it will 
	keep reading each line. 
	readline() also returns the '\n' it finds on the end of each line. 
	readline() has a (,end='') optional parameter

21 Functions Can Return Something
return can set variables to be a value from a function
variables can be assigned to functions
	i.e. def thing_to_do(arg1, arg2):
		     return 0	
	variable = thing_to_do(blue, red)
You can return anything that you can put to the right of an = 
You *can* chain functions within other functions as in the example 
def add(a, b):
	return 0 
what = add(subtract(1,2), divide(3,8))
Even though it might look like programs are run "backwards", e.g. x = 3
	where 3 is assigned to 'x'. It is better to think of it as inside 
	out, or even better as 'order of operations'
Note: int('342') but not int('343.35'), you need to float('343.35')

22 What Do you Know So Far?
Copy all Python code and symbols from previous ex. 

23 Strings, Bytes, and Character Encodings
When reading new code you have never seen before, write down everything
	you have never seen before and save it to look up later. Then go 
	back and re-read the code with new info. 
.strip() kills the white space to the left and right of a string. 
variable.encode(encoding, errors=errors) in this example encoding and 
errors come from the argv and is 'utf-8' and 'strict' 
variable.decode(encoding, errors= errors) is the same thing. 
open("file.txt", encoding="utf-8")
I had a lot of problems getting the command line getting this to print
	any of the UTF-8 encoding. I basically understood everything that 
	was	happening, though I was making no progress on getting things to 
	display	correctly and to be able to really break down some of the 
	Study Drills; Especially some of the byte conversions that seemed
	to come from the standard via Wikipedia
The code here took me a moment to parse out following some of the 
	arguments thorough to their conclusion. 
It is kind of crummy that the advice he gives here is fix it yourself,
	when the solution is so varied, from typesets to what terminal you
	are using. 
There are many kinds of encoding standards. 
Switches, Conventions, and Encodings
American Standard Code for Information Interchange ASCII became the 
	standard for a long time until we realized there are non-English
	speakers hidden around the world that like computers also. 
ASCII maps a number to a letter '90' = 'Z' (capital) = 1011010 which is 
	mapped via a lookup table of sorts. 
In Python Shell
>>> 0b1011010 <- 0b seems to tell Python that this is binary 
90
>>> ord('Z') <- Given a string of length one, return an integer 
					representing the Unicode code point of the character
					when the argument is a unicode object, or the value 
					of the byte when the argument is an 8-bit string.
90
>>> chr(90) <- returns the string representing a character whose Unicode
				    is an integer
'Z'
>>>
ASCII coded characters using one byte at a time. One byte can only hold 
	256 numbers. 
This is where Unicode comes in. 32 bits in encode a Unicode character. 
	4 bytes; This is great since it is not limited in the slightest, 
	however there is a lot of wasted space, even with using 2 bytes. 
	Thus, the solution was to use the most common characters using 8 
	bits, and escape in to the larger numbers when needed to encode 
	other characters. Python convention is UTF-8; Unicode Transformation
	Format 8 Bits. 
If you have raw bytes, you need to .decode() to get the string, and if 
	you have a string you need to .encode(). The mnemonic for this is 
	DBES "deebess", Decode Bytes, Encode Strings. 
Text goes thorugh how the code works, it is pretty simple once you 
	actually follow it through. 
In the command line when running this code, he trys to use 'big5' 
	encoding. Python does not like this
    $ python ex23.py big5 strict
	When Python hits the internal encoding that does not work for it, it
	gets really mad due to the 'strict' error call. However you can use 
	'replace' for the error, and Python will replace it with a '?'. 
	You lose the data, however, the program runs to completion. 

24 More Practice
This is another test exercise, nothing new is presented

25 Even More Practice
Here we solidified calling user defined functions. Created a file 
	library and imported it in to the Python Console and played with the
	lib in there. 
def thing()
	'''Triple quotes in a def will cause Python to see it as 
	documentation for that function. Accessible through 
	'python help thing()' in this case. The triple quotes seem to be 
	called 'documentation comments'. 
.split(' ') <- splits a string up in to a list, in this cast the split
	delineator it the ' ', but anything can be used here. 
sorted(variable) <- temp sorts the words alphabetically
.pop(0); .pop(-1); <- pops off the first (then last) item in a list and 
	if there is a variable assignment, assigns that popped word to that 
	variable. The popped word is also removed from the list. I am not 
	super sure the the '-1' is required since I think .pop pops the last
	item off by default
He gives an example of calling a user defined function on a sentence
	given in the Python Console, that takes that sentence and calls 
	another user defined function using that sentence as the argument
	which returns the sentence, now .split(' '), and then takes that 
	returned value and runs the user function to run a third user 
	function to sort that list of words. 
		This is pretty important because it shows the ability of 
			functions to be passed around if they are well organized, 
			and how they can build on each other. I think I really, 
			need to pay attention to this when it comes to classes. 
Since we ran the Python console within the folder that the file needed	
	to be imported lived we can just import ex25 without needing to 
	call the full file address. 
Triple quotes (documentation comments) can be super valuable for def in 
	different libraries, be cool and document well. 
Instead of import ex25 give from ex25 import * (wildcard) to prevent 
	having to type the ex25 in ex25.function_in_ex25() all of the time.
	I do know that this is not technically considered best practice 
	since it is not technically explicit. 

26 Congratulations, Take a Test!
Nothing to add here, it is just a test. 

27 Memorizing Logic
Everything boils down to True or False
Terms
	and
	or
	not
	!= (not equal)
	== (equal)
	>= (greater-than-or-equal)
	<= (less-than-or-equal)
	True
	False
Truth Tables
NOT	True?
not False	True
not True	False

OR True?
True or True	True
True or False	True
False or True	True
False or False	False

AND True?
True or True	True
True or False	False
False or True	False
False or False	False

NOT OR True?
not (True or True)	False
not (True or False)	False
not (False or True)	Flase
not (False or False)	True

NOT AND True?
not (True or True)	False
not (True or False)	True
not (False or True)	True
not (False or False)	True

!= True?
1 != 0 True
1 != 1 False
0 != 1 True
0 != 0 False

== True?
1 == 0 False
1 == 1 True
0 == 1 False
0 == 0 True

28 Boolean Practice
Equalities always evaluate to True or False
Process to solve Boolean logic
1 Find an equality test ( == or !=) and replace it with its truth.
2 Find each and/or inside parentheses and solve those first.
3 Find each not and invert it.
4 Find and remaining and/or and solve it.
5 When you are done you should have True/False
Python sees True == 1 and False == 0
Side note: != and <> both mean not. Though <> is deprecated and no 
	longer used.

29 What If
Control Flow if-statements
if a < b:
	do_the_thing()
With the if-statement if the equality after the if evaluates to True, it
will run the indented block below, otherwise it will skip the block. 
+= 1 is the "increment by" operator. There are many like this that are 
	all awesome -= 1 and *= 2 etc.

30 Else and If
The colon : at the end of control-flow statements (if, elif, else, etc)
	is your way of telling Python that a block indention is coming and
	to treat it that way. Do not forget the :. 
If you do not indent properly you end up with errors and Logical Errors
elif is a way to follow an initial if statement with additional 
	conditionals, you can have as many as you want. 
else: is a catch all that will run if everything above it is False
	This can be useful, but also dangerous, since it will run when you 
	have a Logical Error in the above statements and can be hard to 
	catch.
For all of these control statements, only one of them will ever run 
	until a new block of if statements are run. 
	
31 Making Decisions
In this ex we play with asking the user for input decisions via choosing
	a number. Then we use that string as a guide for the control flow
	statements that come after. Also nesting of control flow.
	ifs within ifs. 
Be careful not to nest too deeply. If you have to go more than 2 or 3
	deep you probably can do it another way that is better, for example
	calling a different function. 
To evaluate if a number is between two numbers there are a few ways:
	0 < x < 10
	1 <= x < 10
	x in range(1,10)

32 Loops and Lists
A for-loop needs a way to store the results of a loop somewhere, and 
	usually this is with a list. 
list = [1, 2, 3, 4,] or ['dog', 'cat', 1, True'] 
	lists require square brackets
for a_temp_variable in an_iterable_list:
	do_things()
range([int], int, [int]) 
	([starting index], index to stop before, [int to interate by])
Range is an immutable sequence type
variable.append(i) takes i and pushed it on to the end of the variable 
	list

33 While Loops
A while-loop will keep looping until the Boolean Expression it is 
	evaluating becomes false.
This can be dangerous or fun. Depends how you look at things. 
While loops basically repeat the if-statement for the following block of 
	code
Some while-loop rules
1 Make sure that you use while-loops sparingly. Usually a for-loop is 
	better
2 Review your while statments and make sure that the Boolean test will 
	become False at some point
3 When in doubt, print out your test variable at the top and bottom of 
	the while-loop to see what it is doing.
NOTE: A for-loop can only loop over collections of things. A while-loop
	loops as long as the conditional is True

34 Accessing Elements of Lists
To access an element of a list call list[0] the list square bracketed
	by the index of the element you want. 
Emphasis: lists start indexing at 0
Ordinal number = order of objects; like finishers in a race
Cardinal = location of object; like cards in a deck

35 Branches and Functions
sys.exit([int]) is used in this ex 
Since you can pass diferent things to .exit() which exit with a non-zero
	return raises an exception, you can ultimately use the exceptions 
	to try: except: differnt situations you run in to. It seems that it
	uses signed ints here. Though I am not 100% positive with that
He also uses a couple of flag variables in this example. 
I do know that I do need to do a better job of the def fun(args):
	and that the things being passed to them not needing to match and 
	have them translate in my head to what they actually are. i.e. True 
	or a 'string'. 

36 Designing and Debugging
Rules for if-statements
1 Every if-statement must have an else.
2 If this else should never run because it does not make sense, then you
    must use a die function in the else that prints out an error message
	and dies, just like we did in the last exercise. This will find many
	errors.
3 Never nest if-statements more than two deep and always try to do them 
	one deep.
4 Treat if-statements like paragraphs, where each if-elif-else grouping 
	is like a set of sentences. Put blank lines before and after.
5 Your Boolean tests should be simple. If they are complex, move their
	calculations to variables earlier in your function and use a good 
	name for the variable. 
	
Rules for loops 
1 Use while-loops only to loop forever, this means rarely. 
	(PYTHON ONLY: other languages may be different.)
2 for-loops for most other looping, especially of it has a fixed or 
	limited number of things to loop over

Tips for Debugging
1 Do not use a debugger. No specific useful info, lots of extra stuff 
	that does not matter
2 Best way to debug and is to use print() to print out values of 
	variables at different points 
3 Code a little, run a little, fix a little

Best way to work on software is in small chunks
1 On paper write a list of tasks needed to finish the project, this is a
	to do list
2 Pick the easiest thing you can do from the list
3 Write out in English as a guide on how to finish this tasks
4 Write some code out below the English
5 Run script to see if it works
6 Keep working in this cycle of writing, testing, fixing
7 Cross task off list and pick next easiest task
8 As you work remove tasks that are no good and add new needed ones

37 Symbol Review
Keywords

Keyword - Description - Example

and - Logical and - True and False == False
*** as - Part of the with-as statement. - with X as Y: pass            
	*** I wonder where "with" is on this list
*** assert - Assert (ensure) that something is true - assert False, 
	"Error!"
break - Stop this loop right now. - while True: break
*** class - Define a class. - class Person(object)
continue - Do not procass more of the loop, do it again. - while True: 
	continue
def - Define a function. - def X(): pass
del - Delete fron dictionary. - del X[Y]
elif - Else if condition. - if: X; elif: Y; else: J
else - Else condition. - if: X; elif: Y; else: J
*** except - If an exception happens, do this. - except ValueError as e:
	print(e)   ###This is kind of cool, can use in conjunction with try
*** exec - Run a string as Python. - exec 'print("howdy")'
*** finally - Exceptions or not, finally do this no matter what. - 
	finally: pass
for - Loop over a collection of things. - for X in Y: pass
from - Import specific parts of a module. - from x import Y
*** global - Declare that you want a global variable global X
if - If condition. - if:X; elif:Y; else:J
import - Import a module into this one to use. - import os
*** in - Part of for-loops. Also a test of X in Y. - for X in Y: pass 
	also 1 in [1] == True
*** is - Like == to test equality. - 1 is 1 == True             
*** lambda - Creata a short anonymous function - s = lambda y:y ** y; 
	s(3)
not - Logical not. - not True == False
or - Logical or. - True or False == True
*** pass - This block is empty. - def empty(): pass
print - Print this string. - print('this string')
*** raise - Raise an exception when things go wrong. - raise 
	ValueError("No")
return - Exit the function with a return value. - def X(): return Y
*** try - Try this block, and if exception, go to except. - try: pass
	###This is also kind of cool, good for looking to see if something 
		already exists. 
while - While loop. - while X: pass
*** yield - Pause here and return to caller - def X(): yield Y, 
	X().next()

Data Types

Type - Description - Example

True - True Boolean value. - True or False == True
False - False Boolean value. - Falst and True == False
None - Represents "nothing" or "no value."- x = None
bytes - Stores bytes, maybe of textm PNG, file, etc. - x = b"hello"
strings - Stores textual information - x = "hello"
numbers - Stores integers. - i = 100
floats - Stores decimals. - i = 10.389
lists - Stores a list of things. - j = [1, 2, 3, 4]
dicts - Stores a key = value mapping of things. - e = {'x': 1, 'y': 2}

String Escape Sequences

Escape - Description

\\ - Backslash
\' - Single-quote
\" - Double-quote
\a - Bell
\b - Backspace
\f - Formfeed
\n - Newline
\r - Carriage
\t - Tab
\v - Vertical Tab

Old Style String Formats

Escape - Description - Example

%d - Decimal integers (not floating point). - "%d" %45 == "45"
%i - Same as %d. - "%i" % 45 == '45'
%o - Octal number - "%o" % 1000 == '1750'
%u - Unsigned decimal - "%u" % -1000 == '-1000'
%x - Hexadecimal lowercase - "%x" % 1000 == '3e8'
%X - Hexadecimal uppercase - '%X' % 1000 == '3E8'
%e - Exponential notation, lowercase 'e' - "%e" %1000 == '1.000000e+03'
%E - Exponential notation, uppercase 'E' - '%E' %1000 == '1.000000e+03'
%f - Floating point real number - '%f' % 10.34 == '10.340000'
%F - Same as %f - "%F" % 10.34 == '10.340000'
%g - Either %f or %e, whichever is shorter - '%g' % 10.34 == '10.34'
%G - Same as %g but uppercase - "%G" % 10.34 == '10.34'
%c - Character format - '$c' $ 34 == '"'
%r - Repf format (debugging format) - '%r' % int == "<type 'int'>"
%s - String format - "%s there" % 'hi' == 'hi there'
%% - A percent sign - '%g%%' % 10.34 == '10.34%'

Operator - Description - Example

+ - Addition - 2 + 4 == 6
- - Subtraction - 2 - 4 == -2
* - Multiplication - 2 * 4 == 8
** - Power of - 2 ** 4 == 16
/ - Division - 2 / 4 == 0.5
// - Floor division - 2 // 4 == 0 
% - String interpolate or modulus - 2 % 4 == 2
< - Less than - 4 < 4 == False
> - Greater than - 4 > 4 == False
<= - Less than equal - 4 <= 4 == True
>= - Greater than equal - 4 >= 4 == True
== - Equal - 4 == 5 == False
!= - Not equal - 4 != 5 == True
( ) - Parentheses - len('hi') = 2
[ ] - List brackets - [1, 2, 5]
{ } - Dict curly braces - {'x': 5, 'y': 10}
@ - At (decorators) - @classmethod
, - Comma - range(0, 10)
: - Colon - def X():
. - Dot - self.x = 10
= - Assign equal - x = 10
; - Semi-colon - print('hi'); print('there')
+= - Add and assign - x = 1; x += 2
-= - Subtract and assign - x = 1; x -= 2
*= - Multiply and assign - x = 1; x *= 2
/= - Divide and assign - x = 1; x /= 2
//= - Floor divide and assign - x = 1; x //= 2
%= - Modulus assign - x = 1; x %= 2
**= - Power assign - x = 1; x **= 2

38 Doing Things to Lists
The opening "explanation" is how the variable you are using when calling
	a function is technically the first argument of that function, I 
	can only think that this is refering to "self" in the __init__
	
>>> class Thing(object):
		def test(self, message): <--- gotta have the self here else 
									  gonna have a bad time
			message = "Howdy dammit!"
			print(message)
a = thing()
a.test("Howdy!")

variable.split(' ') to split a 'string' in to a [list] 
using .pop() to pop off of one list and assign that element to a 
	variable
then appending that variable to the .split(' ') variable
stuff[1] calling the element at index 1
stuff[-1] calling the element at the last index
' '.join(variable_list)
'#'.join(variable_list[3:5])
	str.join(iterable)
		Return a string which is the concatenation of the strings in 
			iterable. A TypeError will be raised if there are any 
			non-string values in iterable, including bytes objects. The 
			separator between elements is the string providing this 
			method.
				In these cases we are concatenating the list of string
					in variable_list and element 3 and 4 in the slice
					of variable_list with ' ' and '#' separating the 
					words respectively
You can do all kinds of fun things with lists. ex, a deck of cards for a
	game. 
This example would be called a data structure. A data structure ia a 
	formal way to structure (or organize) data (or facts). These can 
	quickly become very complex. 
Lists are one of the most common Data Structures that are used
List is an ordered list of things you want to store and access either 
	randomly or linearly by index. 
When to Use lists
1 Need to maintain order. Note: this is listed order, not sorted order.
	Lists do not inherently sort
2 Access contents randomly by a number. Note: this is using cardinal 
	numbers starting at 0
3 Need to go through the contents of a list linearly (first to last)
	Note: this is a really good application of for-loops
variable.pop(another_variable) means call on pop "variable" with the 
	argument "another_variable"

39 Dictionaries, Oh Lovely Dictionaries
Dictionary (dict) is another data structure. 
It is another way to store data like a list, though instead of only	
	numbers to get the data you can use almost anything. 'keys'
Apparently this lets you use dicts like a database for storing and 
	organizing data. 
>>> a_dict = {'dog': 'gypsy', 'monkey': 'bubba',}
>>> a_dict['dog']
gypsy
>>> a_dict[1] = 'much'
>>> a_dict
{'dog': 'gypsy', 'monkey': 'bubba', 1: 'much'}
Can use both numbers (ints) and strings as keys
To delete entries from a dict:
>>> del a_dict['monkey']
>>> a_dict
{'dog': 'gypsy', 1: 'much'}
Mapping (associating) is *the* key concept in a dictionary. 
.get('key') is how to safely check to see and return the 'value' if that
	key if present in the dict. Otherwise it will return None
>>> a_dict.get('pupper')
				<--- Blank line will indicate a None
>>> a_dict.get('dog')
'gypsy'

if assigning variable = a_dict.get('pupper') and it returns None
	You can use an if statement to do something with that facts
	if variable == False:
		do_a_thing
.get('key'[,default]) can use default in place of an if statement like 
	above. When defaulting to None, it will never raise a KeyError
dicts are another common Data Structure

40 Modules, Classes, and Objects
>>> class MyStuff(object):
...     def __init__(self):
...         self.tangerine = "Test post please ignore"
...     def apple(self):
...         print("The thing is cool.")
...
>>> bubblegum = MyStuff
>>> bubblegum
<class '__main__.MyStuff'>
>>> bubblegum.tangerine
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: type object 'MyStuff' has no attribute 'tangerine'
>>> tree = bubblegum.tangerine
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: type object 'MyStuff' has no attribute 'tangerine'
>>>
No tangerine... really? Something wrong with what I am doing here. 
######STOPPED ON p148



















41 Learning to Speak Object-Oriented
NEED TO GO THROUGH AND PRACTICE oop_test.py

42 Is-A, Has-A, Objects, and Classes
NEED TO GO THROUGH AN PRACTICE ex42.py exercise

43 Basic Object-Oriented Analysis and Designing


























































####STOP ON PAGE 180####
